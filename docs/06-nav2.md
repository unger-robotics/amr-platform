---
title: "Phase 6 – Nav2: Navigation auf Karte (map) – AMR"
file: "docs/06-nav2.md"
version: "v0.1.0"
status: "draft"
last_update: "2025-12-19"
scope: "Projekt-Nachschlagewerk (Master-grade Design, nicht Hochschule)"
---

# Phase 6 – Nav2: Navigation auf Karte (map)

## Zielbild (Outcome)

Der AMR navigiert autonom auf einer Karte:

- RViz2: **2D Pose Estimate** (falls nötig) + **Nav2 Goal** setzen.
- Nav2 plant global + lokal, weicht Hindernissen aus und publiziert **/cmd_vel**.
- Der Robot-Stack setzt **/cmd_vel** in Motorleistung um (über deine micro-ROS/Bridge-Schicht).
- System läuft reproduzierbar im **ROS 2 Jazzy Docker** auf dem Pi 5.

---

## Datenverträge (müssen stabil sein)

### TF-Frames (Minimum)

- `map` → `odom` (von SLAM *oder* AMCL)
- `odom` → `base_link` (von Odom/robot_localization)
- `base_link` → `base_laser` (URDF / robot_state_publisher oder statisch)

> Ohne diese Kette werden Costmaps / Nav2 nicht sauber aktiv.

### Topics (Minimum)

**Nav2 benötigt (Input):**

- `/tf`, `/tf_static`
- `/scan` (`sensor_msgs/LaserScan`) vom RPLidar
- `/odom` (`nav_msgs/Odometry`) aus EKF / wheel odom
- `/map` (`nav_msgs/OccupancyGrid`) aus SLAM Toolbox *oder* Map Server
- `/clock` nur wenn `use_sim_time:=true`

**Nav2 liefert (Output):**

- `/cmd_vel` (`geometry_msgs/Twist` oder `TwistStamped`, je nach Setup)
- Debug/Visualisierung: Costmaps, Plans, BehaviorTree Status etc.

**Wichtig (Entscheidung):**

- Für maximale Kompatibilität: **Firmware/Bridge akzeptiert `/cmd_vel`** als primären Eingang.
  - Optional: interner Re-Publisher `/cmd_vel -> /amr/cmd_vel` (wenn du topic-names strikt trennen willst).

---

## Voraussetzungen (aus Roadmap)

- Phase 2: ROS 2 Jazzy läuft im Docker auf Pi 5 (Netz + Devices sauber).
- Phase 2.5: URDF + TF-Tree konsistent (`base_link`, `base_laser`, …).
- Phase 3: RPLidar A1 publiziert `/scan`.
- Phase 4: robot_localization EKF publiziert `/odometry/filtered` und TF `odom->base_link`.
- Phase 5: SLAM Toolbox publiziert `/map` + TF `map->odom` *oder* du hast eine gespeicherte Map + AMCL.

---

## Installation (im Jazzy-Container)

Im Container (Ubuntu-Base für Jazzy empfohlen):

```bash
sudo apt update
sudo apt install -y \
  ros-${ROS_DISTRO}-navigation2 \
  ros-${ROS_DISTRO}-nav2-bringup \
  ros-${ROS_DISTRO}-slam-toolbox
```

Optional (wenn du „Saved Map + AMCL“ nutzt):

```bash
sudo apt install -y ros-${ROS_DISTRO}-nav2-amcl ros-${ROS_DISTRO}-nav2-map-server
```

---

## Bringup-Strategie (empfohlen: nav2_bringup bringup_launch.py)

### Warum so?

- `bringup_launch.py` kann **Navigation** immer starten und je nach Modus zusätzlich:

  - **SLAM** (wenn `slam:=True`)
  - **Localization** (wenn `slam:=False` und `use_localization:=True`)
- Unterstützt **composed bringup** (`use_composition:=True`) → i.d.R. weniger Overhead.

### Launch-Argumente (relevant)

- `slam:=True|False`
- `map:=/pfad/zur/map.yaml` (nur bei `slam:=False`)
- `params_file:=.../nav2_params.yaml`
- `use_localization:=True|False`
- `use_composition:=True|False`
- `autostart:=true`
- `use_sim_time:=false`

---

## Empfohlene Projektablage (ros2_ws)

Lege in deinem `ros2_ws/src/amr_bringup/` an:

```
amr_bringup/
  launch/
    nav2_bringup.launch.py
  config/
    nav2_params.yaml
  rviz/
    nav2.rviz
  maps/
    <deine_map>.yaml
    <deine_map>.pgm
```

---

## Modus A: Navigation + SLAM (Mapping oder „frische Umgebung“)

### Startreihenfolge (real robot)

1. Robot Interfaces:

   - micro-ROS Agent + Bridge (cmd_vel/odom)
2. Sensoren:

   - RPLidar (`/scan`)
3. EKF:

   - robot_localization (`odom->base_link`, `/odom` bzw. `/odometry/filtered`)
4. Nav2 + SLAM:

   - Nav2 bringup mit `slam:=True`
5. RViz2:

   - Nav2 Panels + TF/Costmaps/Scan anzeigen

### Beispiel-Start

```bash
ros2 launch nav2_bringup bringup_launch.py \
  slam:=True \
  use_sim_time:=False \
  params_file:=/workspaces/ros2_ws/src/amr_bringup/config/nav2_params.yaml \
  use_composition:=True \
  autostart:=true
```

### Smoke-Test (SLAM)

- RViz2: `Map` + `LaserScan` sichtbar
- TF: `map -> odom -> base_link -> base_laser` vorhanden
- RViz2: „Nav2 Goal“ setzen → `/cmd_vel` sollte pulsen

### Map speichern (wenn Mapping ok)

- Nutze den Map-Saver (Server/CLI je nach Setup) und committe in `maps/`.

---

## Modus B: Navigation auf gespeicherter Map (AMCL / Localization)

### Beispiel-Start

```bash
ros2 launch nav2_bringup bringup_launch.py \
  slam:=False \
  map:=/workspaces/ros2_ws/src/amr_bringup/maps/deine_map.yaml \
  use_localization:=True \
  use_sim_time:=False \
  params_file:=/workspaces/ros2_ws/src/amr_bringup/config/nav2_params.yaml \
  use_composition:=True \
  autostart:=true
```

### RViz2 Initialpose

- Einmalig **2D Pose Estimate** setzen (AMCL initialisieren), dann Goals schicken.

---

## nav2_params.yaml – was du wirklich anfassen musst (Minimum-Set)

**1) Frames / Topics**

- `base_frame`: `base_link`
- `odom_frame`: `odom`
- `global_frame`: `map`
- `scan_topic`: `/scan`
- **cmd_vel**: möglichst `/cmd_vel` bis zur Firmware durchreichen

**2) Robot Footprint**

- Für den Start: Kreis-Footprint (robust).
- Radius: grob `0.5 * max(Breite, Länge) + 0.02` (Sicherheitsrand).

**3) Kinematik**

- Diff-Drive: Controller passend wählen (RPP oder MPPI – Start: RPP ist einfacher zu tunen).

**4) Costmaps (Startwerte)**

- `resolution`: typ. `0.05`
- `robot_radius` bzw. `footprint`
- Obstacle Layer: Laser als Quelle

**5) Limits**

- `max_vel_x` etc. an echte Robotik anpassen (erst konservativ).

> Empfehlung: als Basis die nav2_bringup Default-`nav2_params.yaml` nehmen und nur die oben genannten Teile anpassen.

---

## Standard-Smoke-Tests (ohne RViz2)

### 1) Topics vorhanden?

```bash
ros2 topic list | egrep "(/scan|/tf|/odom|/map|/cmd_vel)"
```

### 2) TF-Kette vorhanden?

```bash
ros2 run tf2_ros tf2_echo map base_link
ros2 run tf2_ros tf2_echo base_link base_laser
```

### 3) Nav2 Actions verfügbar?

```bash
ros2 action list | egrep "(navigate_to_pose|follow_waypoints)"
```

### 4) cmd_vel kommt raus?

```bash
ros2 topic echo /cmd_vel --once
```

---

## Häufige Fehlerbilder (kurz)

### Costmap bleibt „inactive“ / Nav2 startet, aber navigiert nicht

- Fast immer: TF-Kette `map->odom->base_link` fehlt oder springt.
- Prüfe zuerst `tf2_echo map base_link`.

### `/scan` da, aber keine Hindernisse im Costmap

- Laser-Frame stimmt nicht (`base_laser` falsch), oder `observation_sources` falsch konfiguriert.

### Robot fährt „falsch herum“ / dreht falsch

- REP-103 Achsenkonvention verletzt (X vorwärts, Z hoch).
- URDF / static TF prüfen.

---

## Definition of Done (Phase 6)

- [ ] Nav2 startet stabil im Jazzy-Docker auf Pi 5.
- [ ] RViz2 zeigt Map + Scan + TF konsistent.
- [ ] Zielpose in RViz2 erzeugt `/cmd_vel` und Robot bewegt sich plausibel.
- [ ] Robot stoppt zuverlässig (Failsafe bleibt aktiv, auch mit Nav2).
- [ ] Parameterdatei + Launch liegen versioniert in `amr_bringup/`.

---

## Nächste sinnvolle Schritte (nach erstem Erfolg)

- Controller-/Costmap-Tuning (Geschwindigkeiten, Inflation, Obstacle-Filter).
- Recovery Behaviors bewerten (Spin/Backup etc. auf realem Robot sicher).
- Optional: TwistStamped end-to-end (wenn du Zeitstempel/Filter sauber willst).

Quellen (für die technischen Kernaussagen im Dokument):

- Nav2: erforderliche Transform-Kette (`map->odom`, `odom->base_link`, `base_link->base_laser`). :contentReference[oaicite:0]{index=0}
- Nav2 Jazzy `bringup_launch.py`: Launch-Argumente (`slam`, `map`, `use_localization`, `use_composition`, `params_file`, …) und Einbindung von `slam_launch.py`, `localization_launch.py`, `navigation_launch.py`. :contentReference[oaicite:1]{index=1}
- Nav2 Tutorial „Navigating while Mapping (SLAM)“: Zusammenspiel Nav2 + SLAM Toolbox inkl. Map-Saver-Service-Hinweis. :contentReference[oaicite:2]{index=2}
- Nav2 Jazzy `slam_launch.py`: nutzt `slam_toolbox` `online_sync_launch.py` (wenn SLAM im Bringup aktiv). :contentReference[oaicite:3]{index=3}

::contentReference[oaicite:4]{index=4}
